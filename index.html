<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line of Sight Analysis Tool - Enhanced</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }
        
        #container {
            display: flex;
            height: 100vh;
            flex-direction: row;
            width: 100%;
            max-width: 100vw;
            overflow-x: hidden;
        }
        
        #map {
            flex: 1;
            height: 100vh;
            min-height: 400px;
        }
        
        #sidebar {
            width: 500px;
            min-width: 400px;
            background: #f5f5f5;
            border-left: 1px solid #ddd;
            overflow-y: auto;
            padding: 0 20px 20px 20px;
            box-sizing: border-box;
        }
        
        /* Mobile responsive design */
        @media (max-width: 768px) {
            * {
                box-sizing: border-box;
            }
            
            html, body {
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }
            
            #container {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
                display: flex;
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
                margin: 0;
                padding: 0;
            }
            
            #map {
                height: 50vh;
                min-height: 300px;
                order: 2;
                width: 100%;
                max-width: 100%;
                margin: 0;
            }
            
            #sidebar {
                width: 100%;
                min-width: auto;
                max-width: 100%;
                border-left: none;
                padding: 0;
                margin: 0;
                height: auto;
                max-height: none;
                display: contents;
            }
            
            .point-entry {
                margin: 5px;
                order: 1;
                width: calc(100% - 10px);
                max-width: calc(100% - 10px);
                padding: 8px;
            }
            
            .info-section {
                order: 3;
                width: calc(100% - 10px);
                max-width: calc(100% - 10px);
                margin: 5px;
                padding: 8px;
            }
            
            .point-fields {
                width: 100%;
                max-width: 100%;
            }
            
            .field-group {
                width: 100%;
                max-width: 100%;
            }
            
            .field-group input {
                max-width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            .point-entry {
                margin: 3px;
                width: calc(100% - 6px);
                max-width: calc(100% - 6px);
                padding: 6px;
            }
            
            .info-section {
                margin: 3px;
                width: calc(100% - 6px);
                max-width: calc(100% - 6px);
                padding: 6px;
            }
            
            #map {
                height: 40vh;
                min-height: 250px;
            }
        }
        
        #elevation-profile {
            width: 100%;
            height: 300px;
            margin: 20px 0 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        @media (max-width: 768px) {
            #elevation-profile {
                height: 250px;
                margin: 5px 0;
                width: calc(100% - 10px);
                max-width: calc(100% - 10px);
            }
        }
        
        @media (max-width: 480px) {
            #elevation-profile {
                height: 220px;
                margin: 3px 0;
                width: calc(100% - 6px);
                max-width: calc(100% - 6px);
            }
        }
        
        
        .info-section {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .info-section h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        /* Page title */
        .page-title {
            background: #e8f5e8;
            color: #2d5a2d;
            margin: 0;
            padding: 8px 20px;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            border-bottom: 1px solid #ddd;
            line-height: 1.2;
        }
        
        @media (max-width: 768px) {
            .page-title {
                padding: 6px 15px;
                font-size: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .page-title {
                padding: 5px 10px;
                font-size: 14px;
            }
        }
        
        
        .controls {
            margin-bottom: 20px;
        }
        
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 8px;
        }
        
        .btn:hover {
            background: #0056b3;
        }
        
        .btn.clear {
            background: #6c757d;
        }
        
        @media (max-width: 480px) {
            .btn {
                padding: 10px 20px;
                font-size: 16px;
                margin-right: 8px;
                margin-bottom: 10px;
            }
            
            .controls {
                display: flex;
                flex-wrap: wrap;
            }
        }
        
        .point-entries {
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            padding: 10px;
        }
        
        .point-entry {
            padding: 8px;
            background: white;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        .point-fields {
            display: grid;
            grid-template-columns: 1fr 150px;
            gap: 8px;
        }
        
        .field-group {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 6px;
        }
        
        .field-group label {
            font-size: 0.85em;
            font-weight: bold;
            color: #555;
            white-space: nowrap;
        }
        
        .field-group input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 0.9em;
            box-sizing: border-box;
        }
        
        .field-group input[type="text"] {
            min-width: 140px;
        }
        
        .field-group span {
            font-size: 0.8em;
            color: #666;
            margin-top: 1px;
        }
        
        @media (max-width: 480px) {
            .point-fields {
                grid-template-columns: 1fr 130px;
                gap: 4px;
            }
            
            .field-group input {
                padding: 6px 4px;
                font-size: 14px;
            }
            
            .field-group input[type="text"] {
                min-width: 120px;
            }
        }
        
        /* Custom marker labels */
        .marker-label {
            background: white;
            border: 2px solid #666;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            text-align: center;
            line-height: 20px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        
        /* GitHub link */
        .github-link {
            background: #24292e;
            color: white;
            text-decoration: none;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 15px;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box;
        }
        
        .github-link:hover {
            background: #1a1e22;
            color: white;
            text-decoration: none;
        }
        
        .github-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="map"></div>
        <div id="sidebar">
            <div class="point-entry" style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd;">
                <div class="point-fields">
                    <div class="field-group">
                        <label for="latlon-a">A (lat,lon):</label>
                        <input type="text" id="latlon-a" placeholder="44.422633,-72.396017" oninput="updateMarkerFromInput('A')">
                    </div>
                    <div class="field-group">
                        <label for="alt-a">Alt (m):</label>
                        <input type="number" id="alt-a" value="10" min="0" max="200" step="0.1" oninput="updateAnalysisLive()">
                    </div>
                </div>
                
                <div class="point-fields" style="margin-top: 10px;">
                    <div class="field-group">
                        <label for="latlon-b">B (lat,lon):</label>
                        <input type="text" id="latlon-b" placeholder="44.422633,-72.396017" oninput="updateMarkerFromInput('B')">
                    </div>
                    <div class="field-group">
                        <label for="alt-b">Alt (m):</label>
                        <input type="number" id="alt-b" value="10" min="0" max="200" step="0.1" oninput="updateAnalysisLive()">
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 id="elevation-profile-header" style="margin: 0;">Elevation Profile</h3>
                    <button class="btn" onclick="clearPoints()" style="padding: 4px 12px; font-size: 0.85em; line-height: 1.2;">Clear Points</button>
                </div>
                <div id="elevation-profile"></div>
            </div>
            
            <div class="info-section">
                <h3>Map Legend</h3>
                <div id="legend">
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border: 2px solid white; border-radius: 50%; margin-right: 8px;"></span>
                        Highest Point
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #ff8c00; border: 2px solid white; border-radius: 50%; margin-right: 8px;"></span>
                        Elevation Peak
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #8b0000; border: 2px solid white; border-radius: 50%; margin-right: 8px;"></span>
                        Obstruction Point
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 3px; background: #28a745; margin-right: 8px;"></span>
                        Clear Path (Green)
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 3px; background: red; margin-right: 8px;"></span>
                        Blocked Path (Red)
                    </div>
                    <div style="margin: 5px 0;">
                        <span style="display: inline-block; width: 12px; height: 12px; background: #0066ff; border: 2px solid white; border-radius: 50%; margin-right: 8px;"></span>
                        Chart Hover Position
                    </div>
                </div>
            </div>
            
            <!-- <div class="info-section">
                <h3>About</h3>
                <div style="font-size: 0.85em; line-height: 1.4; color: #555;">
                    <p style="margin: 0 0 8px 0;">This tool calculates line-of-sight between two points by:</p>
                    <ul style="margin: 0; padding-left: 16px;">
                        <li style="margin-bottom: 4px;">Sampling elevation data along the path</li>
                        <li style="margin-bottom: 4px;">Adding antenna heights to terrain elevation</li>
                        <li style="margin-bottom: 4px;">Drawing a straight line between elevated points</li>
                        <li style="margin-bottom: 4px;">Checking if terrain blocks this line</li>
                    </ul>
                    <p style="margin: 8px 0 0 0;"><strong>Fresnel zone:</strong> The calculation includes 60% of the first Fresnel zone clearance (assumed 915 MHz frequency) to account for radio wave diffraction effects.</p>
                </div>
            </div> -->
            
            <div class="info-section">
                <a href="https://github.com/waterbearfieldschool/line-of-sight" target="_blank" class="github-link">
                    <svg class="github-icon" viewBox="0 0 16 16">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    View on GitHub
                </a>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let selectedPoints = [];
        let markers = [];
        let pathLine = null;
        let elevationData = [];
        let elevationMarkers = [];
        let isAnalyzing = false;
        let lineOfSightClear = false;
        let hoverMarker = null;
        let liveUpdateTimeout = null;
        
        // Initialize the map
        var map = L.map('map').setView([44.422633, -72.396017], 11);

        // Define base layers
        var topoLayer = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Map data: &copy; <a href="https://www.usgs.gov/">USGS</a>',
            maxZoom: 16
        });

        var satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        // Add default layer
        topoLayer.addTo(map);

        // Define base layers for layer control
        var baseLayers = {
            "Topographic": topoLayer,
            "Satellite": satelliteLayer
        };

        // Add layer control
        L.control.layers(baseLayers).addTo(map);

        // Map click handler
        map.on('click', function(e) {
            if (selectedPoints.length < 2) {
                addPoint(e.latlng);
            }
        });

        function createCustomMarker(label) {
            return L.divIcon({
                className: 'marker-label',
                html: label,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        function addPoint(latlng) {
            selectedPoints.push(latlng);
            
            // Create draggable marker with custom label
            const label = selectedPoints.length === 1 ? 'A' : 'B';
            const marker = L.marker(latlng, {
                icon: createCustomMarker(label),
                title: `Point ${label}`,
                draggable: true
            }).addTo(map);
            
            marker.bindPopup(`Point ${label}<br>Lat: ${latlng.lat.toFixed(6)}<br>Lng: ${latlng.lng.toFixed(6)}`);
            
            // Add drag event listener
            const pointIndex = selectedPoints.length - 1;
            setupMarkerDragEvents(marker, pointIndex);
            
            markers.push(marker);
            
            updatePointFields();
            
            if (selectedPoints.length === 2) {
                drawPath(true); // Auto-fit when first placing points
                // Automatically analyze when two points are placed
                setTimeout(() => {
                    if (!isAnalyzing) {
                        analyzeLineOfSight();
                    }
                }, 100);
            }
        }

        function getOrderedPoints() {
            if (selectedPoints.length !== 2) return selectedPoints;
            
            // Order points from leftmost (westernmost) to rightmost (easternmost)
            if (selectedPoints[0].lng <= selectedPoints[1].lng) {
                return [selectedPoints[0], selectedPoints[1]]; // A to B
            } else {
                return [selectedPoints[1], selectedPoints[0]]; // B to A
            }
        }

        function drawPath(autoFit = false) {
            if (pathLine) {
                map.removeLayer(pathLine);
            }
            
            // Choose color based on line of sight status
            const pathColor = lineOfSightClear ? '#28a745' : '#dc3545'; // Green if clear, red if blocked
            
            pathLine = L.polyline(selectedPoints, {
                color: pathColor,
                weight: 3,
                opacity: 0.8,
                dashArray: lineOfSightClear ? null : '10, 5' // Solid if clear, dashed if blocked
            }).addTo(map);
            
            // Only auto-fit when explicitly requested (not during drag)
            if (autoFit) {
                const group = new L.featureGroup(markers.concat([pathLine]));
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }

        function updatePointFields() {
            // Update the point entry fields with current coordinates
            if (selectedPoints.length >= 1) {
                document.getElementById('latlon-a').value = `${selectedPoints[0].lat.toFixed(6)},${selectedPoints[0].lng.toFixed(6)}`;
            } else {
                document.getElementById('latlon-a').value = '';
            }
            
            if (selectedPoints.length >= 2) {
                document.getElementById('latlon-b').value = `${selectedPoints[1].lat.toFixed(6)},${selectedPoints[1].lng.toFixed(6)}`;
            } else {
                document.getElementById('latlon-b').value = '';
            }
        }

        function updateMarkerFromInput(pointLabel) {
            const latlonId = pointLabel === 'A' ? 'latlon-a' : 'latlon-b';
            const pointIndex = pointLabel === 'A' ? 0 : 1;
            
            const latlonValue = document.getElementById(latlonId).value.trim();
            
            // Parse lat,lon format with validation
            const coords = parseLatLonInput(latlonValue);
            if (!coords) {
                // Invalid format or coordinates, add visual feedback
                document.getElementById(latlonId).style.borderColor = '#dc3545';
                document.getElementById(latlonId).style.backgroundColor = '#fff5f5';
                return;
            }
            
            // Valid coordinates, reset styling
            document.getElementById(latlonId).style.borderColor = '#ddd';
            document.getElementById(latlonId).style.backgroundColor = '';
            
            const { lat, lon } = coords;
            
            const newLatLng = L.latLng(lat, lon);
            
            // If this is a new point (not yet in selectedPoints)
            if (pointIndex >= selectedPoints.length) {
                // Add new point
                selectedPoints.push(newLatLng);
                
                // Create new marker
                const marker = L.marker(newLatLng, {
                    icon: createCustomMarker(pointLabel),
                    title: `Point ${pointLabel}`,
                    draggable: true
                }).addTo(map);
                
                marker.bindPopup(`Point ${pointLabel}<br>Lat: ${lat.toFixed(6)}<br>Lng: ${lon.toFixed(6)}`);
                
                // Add drag event listeners
                setupMarkerDragEvents(marker, pointIndex);
                markers.push(marker);
                
            } else {
                // Update existing point
                selectedPoints[pointIndex] = newLatLng;
                
                // Update marker position
                if (markers[pointIndex]) {
                    markers[pointIndex].setLatLng(newLatLng);
                    markers[pointIndex].setPopupContent(`Point ${pointLabel}<br>Lat: ${lat.toFixed(6)}<br>Lng: ${lon.toFixed(6)}`);
                }
            }
            
            // Update path and analysis if we have two points
            if (selectedPoints.length === 2) {
                drawPath();
                // Auto-analyze after coordinate change
                setTimeout(() => {
                    if (!isAnalyzing) {
                        analyzeLineOfSight();
                    }
                }, 300);
            } else if (selectedPoints.length === 1) {
                // If only one point, clear any existing path/analysis
                if (pathLine) {
                    map.removeLayer(pathLine);
                    pathLine = null;
                }
                clearElevationMarkers();
                clearElevationProfile();
            }
        }

        function setupMarkerDragEvents(marker, pointIndex) {
            marker.on('dragstart', function(e) {
                // Disable map dragging and zoom during marker drag
                map.dragging.disable();
                map.touchZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
                map.boxZoom.disable();
                map.keyboard.disable();
            });
            
            marker.on('drag', function(e) {
                selectedPoints[pointIndex] = e.target.getLatLng();
                updatePointFields();
                if (selectedPoints.length === 2) {
                    drawPath(); // Don't auto-fit during drag
                }
            });
            
            marker.on('dragend', function(e) {
                // Re-enable map interactions
                map.dragging.enable();
                map.touchZoom.enable();
                map.doubleClickZoom.enable();
                map.scrollWheelZoom.enable();
                map.boxZoom.enable();
                map.keyboard.enable();
                
                selectedPoints[pointIndex] = e.target.getLatLng();
                updatePointFields();
                const newLabel = pointIndex === 0 ? 'A' : 'B';
                marker.setPopupContent(`Point ${newLabel}<br>Lat: ${e.target.getLatLng().lat.toFixed(6)}<br>Lng: ${e.target.getLatLng().lng.toFixed(6)}`);
                
                if (selectedPoints.length === 2) {
                    drawPath(); // Still don't auto-fit after drag
                    // Auto-analyze after drag
                    setTimeout(() => {
                        if (!isAnalyzing) {
                            analyzeLineOfSight();
                        }
                    }, 500);
                }
            });
        }

        function parseLatLonInput(input) {
            if (!input) return null;
            
            // Remove any whitespace and split by comma
            const parts = input.replace(/\s/g, '').split(',');
            
            if (parts.length !== 2) {
                return null; // Must have exactly 2 parts
            }
            
            const lat = parseFloat(parts[0]);
            const lon = parseFloat(parts[1]);
            
            // Validate lat/lon values
            if (isNaN(lat) || isNaN(lon)) {
                return null; // Invalid numbers
            }
            
            if (lat < -90 || lat > 90) {
                return null; // Latitude out of range
            }
            
            if (lon < -180 || lon > 180) {
                return null; // Longitude out of range
            }
            
            return { lat, lon };
        }

        function clearPoints() {
            selectedPoints = [];
            elevationData = [];
            lineOfSightClear = false;
            
            // Remove markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            
            // Remove elevation markers
            clearElevationMarkers();
            
            // Remove hover marker
            clearHoverMarker();
            
            // Remove path line
            if (pathLine) {
                map.removeLayer(pathLine);
                pathLine = null;
            }
            
            updatePointFields();
            clearElevationProfile();
        }

        function clearElevationMarkers() {
            elevationMarkers.forEach(marker => map.removeLayer(marker));
            elevationMarkers = [];
        }

        function clearHoverMarker() {
            if (hoverMarker) {
                map.removeLayer(hoverMarker);
                hoverMarker = null;
            }
        }

        function updateHoverMarker(distance) {
            // Calculate position along the line based on distance
            if (selectedPoints.length !== 2 || elevationData.length === 0) {
                clearHoverMarker();
                return;
            }

            // Find the closest elevation data point
            let closestPoint = elevationData[0];
            let minDiff = Math.abs(elevationData[0].distance - distance);
            
            for (let i = 1; i < elevationData.length; i++) {
                const diff = Math.abs(elevationData[i].distance - distance);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestPoint = elevationData[i];
                }
            }

            // Remove existing hover marker
            clearHoverMarker();

            // Create new hover marker
            hoverMarker = L.circleMarker([closestPoint.lat, closestPoint.lng], {
                radius: 8,
                fillColor: '#0066ff',
                color: '#ffffff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8,
                zIndexOffset: 1000 // Keep it on top
            }).addTo(map);

            // Add popup with elevation info
            const popupContent = `
                <strong>Profile Position</strong><br>
                Distance: ${(closestPoint.distance / 1000).toFixed(2)} km<br>
                Elevation: ${closestPoint.elevation.toFixed(1)} m (${(closestPoint.elevation * 3.28084).toFixed(0)} ft)
            `;
            hoverMarker.bindPopup(popupContent);
        }

        function updateHoverInfo(distanceM, plotlyPoints) {
            // Hover info display removed from UI
        }

        function clearHoverInfo() {
            // Hover info display removed from UI
        }

        function updateStatus(message, type) {
            // Status display removed from UI
        }

        function updateDistanceInfo() {
            // Distance info display removed from UI
        }

        function calculateDistance(latlng1, latlng2) {
            const R = 6371000; // Earth's radius in meters
            const lat1Rad = latlng1.lat * Math.PI / 180;
            const lat2Rad = latlng2.lat * Math.PI / 180;
            const deltaLatRad = (latlng2.lat - latlng1.lat) * Math.PI / 180;
            const deltaLngRad = (latlng2.lng - latlng1.lng) * Math.PI / 180;

            const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
                    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                    Math.sin(deltaLngRad / 2) * Math.sin(deltaLngRad / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        function updateAnalysisLive() {
            // Clear existing timeout to debounce rapid changes
            if (liveUpdateTimeout) {
                clearTimeout(liveUpdateTimeout);
            }
            
            // Set a short delay to avoid overwhelming updates while typing
            liveUpdateTimeout = setTimeout(() => {
                updateAnalysis();
            }, 250); // 250ms delay
        }

        function updateAnalysis() {
            // Called when antenna heights change
            if (selectedPoints.length === 2 && elevationData.length > 0 && !isAnalyzing) {
                // Recalculate with new antenna heights immediately (no setTimeout delay)
                const hasLineOfSight = calculateLineOfSight();
                lineOfSightClear = hasLineOfSight;
                
                drawPath(); // Update path color
                plotElevationProfile(); // Update profile with new antenna heights
                addElevationMarkers(); // Update obstruction markers
                
                // Line of sight status reflected in graph color
            }
        }

        async function analyzeLineOfSight() {
            if (selectedPoints.length !== 2) {
                return; // Please select two points first
                return;
            }
            
            if (isAnalyzing) {
                return; // Prevent multiple simultaneous analyses
            }
            
            isAnalyzing = true;
            // Fetching elevation data...
            
            try {
                await getElevationProfile();
                const hasLineOfSight = calculateLineOfSight();
                lineOfSightClear = hasLineOfSight;
                
                updateDistanceInfoWithElevation();
                plotElevationProfile();
                addElevationMarkers();
                drawPath(); // Update path color based on result
                
                // Line of sight status reflected in graph color
            } catch (error) {
                console.error('Error during analysis:', error);
                console.error('Error fetching elevation data');
            } finally {
                isAnalyzing = false;
            }
        }

        function getAntennaHeights() {
            const orderedPoints = getOrderedPoints();
            let antenna1Height, antenna2Height;
            
            if (selectedPoints.length === 2) {
                if (orderedPoints[0] === selectedPoints[0]) {
                    // A is leftmost
                    antenna1Height = parseFloat(document.getElementById('alt-a').value) || 10;
                    antenna2Height = parseFloat(document.getElementById('alt-b').value) || 10;
                } else {
                    // B is leftmost
                    antenna1Height = parseFloat(document.getElementById('alt-b').value) || 10;
                    antenna2Height = parseFloat(document.getElementById('alt-a').value) || 10;
                }
            } else {
                antenna1Height = parseFloat(document.getElementById('alt-a').value) || 10;
                antenna2Height = parseFloat(document.getElementById('alt-b').value) || 10;
            }
            
            return { antenna1Height, antenna2Height };
        }

        async function getElevationProfile() {
            const numPoints = 30; // Reduced for better performance
            elevationData = [];
            
            // Use ordered points (leftmost to rightmost)
            const orderedPoints = getOrderedPoints();
            
            // Prepare all coordinates for batch request
            const coordinates = [];
            for (let i = 0; i <= numPoints; i++) {
                const ratio = i / numPoints;
                const lat = orderedPoints[0].lat + (orderedPoints[1].lat - orderedPoints[0].lat) * ratio;
                const lng = orderedPoints[0].lng + (orderedPoints[1].lng - orderedPoints[0].lng) * ratio;
                coordinates.push({lat, lng, ratio, index: i});
            }
            
            // Try batch request first, fallback to individual requests
            try {
                const batchElevations = await getBatchElevations(coordinates);
                
                for (let i = 0; i < coordinates.length; i++) {
                    const coord = coordinates[i];
                    const distance = calculateDistance(orderedPoints[0], {lat: coord.lat, lng: coord.lng});
                    
                    elevationData.push({
                        distance: distance,
                        elevation: batchElevations[i] || 0,
                        lat: coord.lat,
                        lng: coord.lng
                    });
                }
            } catch (error) {
                // Fallback to individual requests with delay
                for (let i = 0; i < coordinates.length; i++) {
                    const coord = coordinates[i];
                    const elevation = await getElevation(coord.lat, coord.lng);
                    const distance = calculateDistance(orderedPoints[0], {lat: coord.lat, lng: coord.lng});
                    
                    elevationData.push({
                        distance: distance,
                        elevation: elevation,
                        lat: coord.lat,
                        lng: coord.lng
                    });
                    
                    // Small delay to avoid overwhelming the API
                    if (i < coordinates.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }
        }

        async function getBatchElevations(coordinates) {
            // Batch request for Open-Elevation API
            const locations = coordinates.map(c => `${c.lat},${c.lng}`).join('|');
            
            try {
                const response = await fetch(
                    `https://api.open-elevation.com/api/v1/lookup?locations=${locations}`
                );
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    return data.results.map(result => result.elevation);
                }
                throw new Error('No batch results');
            } catch (error) {
                console.error('Batch elevation request failed:', error);
                throw error;
            }
        }

        async function getElevation(lat, lng) {
            // Using Open-Elevation API (CORS-enabled)
            try {
                const response = await fetch(
                    `https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`
                );
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    return data.results[0].elevation;
                }
                return 0;
            } catch (error) {
                console.error('Error fetching elevation:', error);
                // Fallback to basic terrain estimation if API fails
                return estimateElevationFromTerrain(lat, lng);
            }
        }

        function estimateElevationFromTerrain(lat, lng) {
            // Simple terrain estimation based on Vermont topography
            // This is a fallback when elevation APIs are unavailable
            const baseElevation = 300; // Base elevation for Vermont in meters
            const latVariation = Math.sin((lat - 44) * 20) * 200;
            const lngVariation = Math.cos((lng + 72) * 15) * 150;
            return Math.max(0, baseElevation + latVariation + lngVariation + Math.random() * 50);
        }

        function calculateLineOfSight() {
            if (elevationData.length < 2) return false;
            
            const startPoint = elevationData[0];
            const endPoint = elevationData[elevationData.length - 1];
            
            // Get custom antenna heights
            const { antenna1Height, antenna2Height } = getAntennaHeights();
            const startHeight = startPoint.elevation + antenna1Height;
            const endHeight = endPoint.elevation + antenna2Height;
            
            // Calculate line of sight for each intermediate point
            for (let i = 1; i < elevationData.length - 1; i++) {
                const point = elevationData[i];
                const ratio = point.distance / elevationData[elevationData.length - 1].distance;
                
                // Calculate expected height along direct line of sight
                const expectedHeight = startHeight + (endHeight - startHeight) * ratio;
                
                // Check if terrain blocks the line (with 60% Fresnel zone clearance)
                const fresnelRadius = calculateFresnelRadius(point.distance, elevationData[elevationData.length - 1].distance, 915); // 915 MHz
                const requiredClearance = expectedHeight - (fresnelRadius * 0.6);
                
                if (point.elevation > requiredClearance) {
                    return false; // Line of sight is blocked
                }
            }
            
            return true; // Line of sight is clear
        }

        function calculateFresnelRadius(d1, d2, frequencyMHz) {
            // Calculate first Fresnel zone radius at a point
            // d1: distance from transmitter to point (meters)
            // d2: total distance (meters)
            // frequencyMHz: frequency in MHz
            
            const d2_minus_d1 = d2 - d1;
            const lambda = 300 / frequencyMHz; // wavelength in meters
            
            return Math.sqrt((lambda * d1 * d2_minus_d1) / d2);
        }

        function updateDistanceInfoWithElevation() {
            // Distance info display removed from UI
        }

        function plotElevationProfile() {
            if (elevationData.length === 0) return;
            
            const distances = elevationData.map(d => d.distance / 1000); // Convert to km
            const elevations = elevationData.map(d => d.elevation);
            
            // Calculate line of sight line with custom antenna heights
            const { antenna1Height, antenna2Height } = getAntennaHeights();
            const startHeight = elevations[0] + antenna1Height;
            const endHeight = elevations[elevations.length - 1] + antenna2Height;
            const losLine = distances.map((d, i) => {
                const ratio = i / (distances.length - 1);
                return startHeight + (endHeight - startHeight) * ratio;
            });
            
            // Determine which point is A and which is B based on ordering
            const orderedPoints = getOrderedPoints();
            let leftLabel, rightLabel;
            if (orderedPoints[0] === selectedPoints[0]) {
                leftLabel = 'A';
                rightLabel = 'B';
            } else {
                leftLabel = 'B';
                rightLabel = 'A';
            }
            
            const trace1 = {
                x: distances,
                y: elevations,
                type: 'scatter',
                mode: 'lines',
                fill: 'tonexty',
                name: 'Terrain',
                line: {color: 'brown'},
                hovertemplate: '<extra></extra>' // Hide default hover tooltip
            };
            
            const trace2 = {
                x: distances,
                y: losLine,
                type: 'scatter',
                mode: 'lines',
                name: 'Line of Sight',
                line: {color: lineOfSightClear ? '#28a745' : '#dc3545', dash: 'dash'},
                hovertemplate: '<extra></extra>' // Hide default hover tooltip
            };
            
            const layout = {
                xaxis: {
                    title: `Distance from ${leftLabel} (km)`,
                    fixedrange: true
                },
                yaxis: {
                    title: 'Elevation (m)',
                    fixedrange: true
                },
                showlegend: false,
                margin: {l: 50, r: 50, t: 20, b: 50},
                hovermode: 'x unified',
                dragmode: false
            };
            
            const config = {
                responsive: true,
                displayModeBar: false,
                scrollZoom: false,
                doubleClick: false,
                showTips: false,
                editable: false,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d']
            };
            
            // Update the header with point direction
            const headerElement = document.getElementById('elevation-profile-header');
            if (headerElement) {
                headerElement.textContent = `Elevation Profile ${leftLabel} --> ${rightLabel}`;
            }
            
            Plotly.newPlot('elevation-profile', [trace1, trace2], layout, config);
            
            // Add hover event listeners
            document.getElementById('elevation-profile').on('plotly_hover', function(data) {
                if (data.points && data.points.length > 0) {
                    const distanceKm = data.points[0].x;
                    const distanceM = distanceKm * 1000; // Convert back to meters
                    updateHoverMarker(distanceM);
                    updateHoverInfo(distanceM, data.points);
                }
            });
            
            document.getElementById('elevation-profile').on('plotly_unhover', function(data) {
                clearHoverMarker();
                clearHoverInfo();
            });
        }

        function clearElevationProfile() {
            document.getElementById('elevation-profile').innerHTML = '';
            const headerElement = document.getElementById('elevation-profile-header');
            if (headerElement) {
                headerElement.textContent = 'Elevation Profile';
            }
        }

        function addElevationMarkers() {
            // Clear existing elevation markers
            clearElevationMarkers();
            
            if (elevationData.length === 0) return;
            
            // Find the highest elevation points
            const elevations = elevationData.map(d => d.elevation);
            const maxElevation = Math.max(...elevations);
            const highThreshold = maxElevation * 0.9; // Points within 90% of max elevation
            
            // Find peaks (local maxima)
            const peaks = [];
            for (let i = 1; i < elevationData.length - 1; i++) {
                const current = elevationData[i];
                const prev = elevationData[i - 1];
                const next = elevationData[i + 1];
                
                // Check if it's a local maximum above threshold
                if (current.elevation > prev.elevation && 
                    current.elevation > next.elevation && 
                    current.elevation > highThreshold) {
                    peaks.push(current);
                }
            }
            
            // Always include the absolute highest point
            const absoluteHighest = elevationData.find(d => d.elevation === maxElevation);
            if (absoluteHighest && !peaks.some(p => p.lat === absoluteHighest.lat && p.lng === absoluteHighest.lng)) {
                peaks.push(absoluteHighest);
            }
            
            // Add markers for peaks
            peaks.forEach((peak, index) => {
                const isHighest = peak.elevation === maxElevation;
                
                const elevationMarker = L.circleMarker([peak.lat, peak.lng], {
                    radius: isHighest ? 10 : 7,
                    fillColor: isHighest ? '#ff0000' : '#ff8c00',
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                
                const orderedPoints = getOrderedPoints();
                const distanceFromStart = calculateDistance(orderedPoints[0], {lat: peak.lat, lng: peak.lng});
                
                const popupContent = `
                    <strong>${isHighest ? 'Highest Point' : 'Peak'}</strong><br>
                    Elevation: ${peak.elevation.toFixed(1)} m (${(peak.elevation * 3.28084).toFixed(0)} ft)<br>
                    Distance: ${(distanceFromStart / 1000).toFixed(2)} km from leftmost point
                `;
                
                elevationMarker.bindPopup(popupContent);
                elevationMarkers.push(elevationMarker);
            });
            
            // Add potential obstruction markers (points that might block line of sight)
            const obstructions = findObstructions();
            obstructions.forEach(obstruction => {
                const obstructionMarker = L.circleMarker([obstruction.lat, obstruction.lng], {
                    radius: 6,
                    fillColor: '#8b0000',
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.9
                }).addTo(map);
                
                const orderedPoints = getOrderedPoints();
                const distanceFromStart = calculateDistance(orderedPoints[0], {lat: obstruction.lat, lng: obstruction.lng});
                
                const popupContent = `
                    <strong>⚠️ Potential Obstruction</strong><br>
                    Elevation: ${obstruction.elevation.toFixed(1)} m (${(obstruction.elevation * 3.28084).toFixed(0)} ft)<br>
                    Distance: ${(distanceFromStart / 1000).toFixed(2)} km from leftmost point<br>
                    Clearance needed: ${obstruction.clearanceNeeded.toFixed(1)} m
                `;
                
                obstructionMarker.bindPopup(popupContent);
                elevationMarkers.push(obstructionMarker);
            });
        }

        function findObstructions() {
            if (elevationData.length < 3) return [];
            
            const obstructions = [];
            const startPoint = elevationData[0];
            const endPoint = elevationData[elevationData.length - 1];
            
            // Get custom antenna heights
            const { antenna1Height, antenna2Height } = getAntennaHeights();
            const startHeight = startPoint.elevation + antenna1Height;
            const endHeight = endPoint.elevation + antenna2Height;
            
            for (let i = 1; i < elevationData.length - 1; i++) {
                const point = elevationData[i];
                const ratio = point.distance / elevationData[elevationData.length - 1].distance;
                
                // Calculate expected height along direct line of sight
                const expectedHeight = startHeight + (endHeight - startHeight) * ratio;
                
                // Calculate Fresnel zone clearance
                const fresnelRadius = calculateFresnelRadius(point.distance, elevationData[elevationData.length - 1].distance, 915);
                const requiredClearance = expectedHeight - (fresnelRadius * 0.6);
                
                // Check if this point blocks the line of sight
                if (point.elevation > requiredClearance) {
                    obstructions.push({
                        ...point,
                        clearanceNeeded: point.elevation - requiredClearance,
                        expectedHeight: expectedHeight,
                        fresnelRadius: fresnelRadius
                    });
                }
            }
            
            return obstructions;
        }
    </script>
</body>
</html>